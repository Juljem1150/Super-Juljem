 import pygame
import pygame.gfxdraw
import sys
import math

pygame.init()

# Bildschirmauflösung für Samsung Galaxy A54 im Querformat (3 mm kleiner)
WIDTH, HEIGHT = 2352, 1032  # Ursprünglich ca. 2400x1080, minus ca. 48 Pixel pro Dimension
FPS = 60

# Farben (RGB)
WHITE       = (255, 255, 255)
BLACK       = (0, 0, 0)
GRAY        = (100, 100, 100)
DARK_GRAY   = (50, 50, 50)
LIGHT_GRAY  = (180, 180, 180)
SKY_TOP     = (25, 120, 220)
SKY_BOTTOM  = (135, 206, 235)
GREEN       = (34, 139, 34)
RED         = (200, 0, 0)
BLUE        = (0, 0, 200)
SKIN        = (255, 220, 177)

screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Super Juljem")
clock = pygame.time.Clock()

# Konstanter: Alle schwebenden Plattformen werden zusätzlich PLATFORM_OFFSET Pixel tiefer gezeichnet.
PLATFORM_OFFSET = 150

# -----------------------------------------------------------------------------
# Hintergrund: Sanfter vertikaler Farbverlauf
# -----------------------------------------------------------------------------
def draw_gradient_background(surface, top_color, bottom_color):
    h = surface.get_height()
    w = surface.get_width()
    for y in range(h):
        ratio = y / h
        color = (
            int(top_color[0]*(1 - ratio) + bottom_color[0]*ratio),
            int(top_color[1]*(1 - ratio) + bottom_color[1]*ratio),
            int(top_color[2]*(1 - ratio) + bottom_color[2]*ratio)
        )
        pygame.draw.line(surface, color, (0, y), (w, y))

# -----------------------------------------------------------------------------
# LEVEL KONFIGURATIONEN (10 Level)
#
# Ursprüngliche (Portrait-)Werte wurden skaliert:
#   factor_x ≈ 2.222   und   factor_y = 0.8
# Die Y-Koordinaten beziehen sich auf das ursprüngliche Layout; später wird PLATFORM_OFFSET addiert.
# -----------------------------------------------------------------------------
levels = {
    "Level 1": {
         "ground_width": 17778,  # 8000 * 2.222
         "platforms": [
             (667, 720, 889, 16),   # (300,900,400,20)
             (1778, 680, 889, 16),  # (800,850,400,20)
             (2889, 640, 889, 16),  # (1300,800,400,20)
             (4000, 600, 889, 16),  # (1800,750,400,20)
             (5111, 560, 889, 16),  # (2300,700,400,20)
             (6222, 600, 889, 16)   # (2800,750,400,20)
         ],
         "finish_x": 16665,   # Ursprünglich festgelegt – wird später ignoriert
         "difficulty": 1.0
    },
    "Level 2": {
         "ground_width": 19998,
         "platforms": [
             (889, 728, 778, 16),
             (1889, 696, 778, 16),
             (2889, 664, 778, 16),
             (3889, 632, 778, 16),
             (4889, 600, 778, 16),
             (5889, 568, 778, 16),
             (6889, 536, 778, 16)
         ],
         "finish_x": 18887,
         "difficulty": 1.1
    },
    "Level 3": {
         "ground_width": 22220,
         "platforms": [
             (777, 736, 889, 16),
             (1778, 704, 889, 16),
             (2778, 672, 889, 16),
             (3778, 640, 889, 16),
             (4778, 608, 889, 16),
             (5778, 576, 889, 16),
             (6778, 544, 889, 16)
         ],
         "finish_x": 21109,
         "difficulty": 1.2
    },
    "Level 4": {
         "ground_width": 24442,
         "platforms": [
             (1111, 720, 1000, 16),
             (2222, 680, 1000, 16),
             (3333, 640, 1000, 16),
             (4444, 600, 1000, 16),
             (5556, 560, 1000, 16),
             (6667, 520, 1000, 16),
             (7777, 480, 1000, 16)
         ],
         "finish_x": 23331,
         "difficulty": 1.3
    },
    "Level 5": {
         "ground_width": 26664,
         "platforms": [
             (889, 752, 1111, 16),
             (2000, 720, 1111, 16),
             (3111, 688, 1111, 16),
             (4222, 656, 1111, 16),
             (5333, 624, 1111, 16),
             (6444, 592, 1111, 16),
             (7556, 560, 1111, 16)
         ],
         "finish_x": 25553,
         "difficulty": 1.4
    },
    "Level 6": {
         "ground_width": 28886,
         "platforms": [
             (1111, 744, 1000, 16),
             (2222, 712, 1000, 16),
             (3333, 680, 1000, 16),
             (4444, 648, 1000, 16),
             (5556, 616, 1000, 16),
             (6667, 584, 1000, 16),
             (7777, 552, 1000, 16),
             (8889, 520, 1000, 16)
         ],
         "finish_x": 27775,
         "difficulty": 1.5
    },
    "Level 7": {
         "ground_width": 31108,
         "platforms": [
             (1333, 736, 889, 16),
             (2444, 704, 889, 16),
             (3556, 672, 889, 16),
             (4667, 640, 889, 16),
             (5778, 608, 889, 16),
             (6889, 576, 889, 16),
             (8000, 544, 889, 16),
             (9111, 512, 889, 16)
         ],
         "finish_x": 29997,
         "difficulty": 1.6
    },
    "Level 8": {
         "ground_width": 33330,
         "platforms": [
             (1111, 760, 1000, 16),
             (2333, 728, 1000, 16),
             (3556, 696, 1000, 16),
             (4778, 664, 1000, 16),
             (6000, 632, 1000, 16),
             (7222, 600, 1000, 16),
             (8444, 568, 1000, 16),
             (9667, 536, 1000, 16),
             (10889, 504, 1000, 16)
         ],
         "finish_x": 32223,
         "difficulty": 1.7
    },
    "Level 9": {
         "ground_width": 35552,
         "platforms": [
             (1333, 752, 1111, 16),
             (2667, 720, 1111, 16),
             (4000, 688, 1111, 16),
             (5333, 656, 1111, 16),
             (6667, 624, 1111, 16),
             (8000, 592, 1111, 16),
             (9333, 560, 1111, 16),
             (10667, 528, 1111, 16)
         ],
         "finish_x": 34441,
         "difficulty": 1.8
    },
    "Level 10": {
         "ground_width": 37774,
         "platforms": [
             (1556, 744, 1000, 16),
             (2889, 712, 1000, 16),
             (4222, 680, 1000, 16),
             (5556, 648, 1000, 16),
             (6889, 616, 1000, 16),
             (8222, 584, 1000, 16),
             (9556, 552, 1000, 16),
             (10889, 520, 1000, 16),
             (12222, 488, 1000, 16)
         ],
         "finish_x": 36663,
         "difficulty": 1.9
    }
}

# -----------------------------------------------------------------------------
# GLOBAL: aktuell maximal freigeschaltetes Level (beginnt bei 1)
# -----------------------------------------------------------------------------
max_unlocked = 1

# -----------------------------------------------------------------------------
# STARTMENÜ (inkl. Levelauswahl)
# -----------------------------------------------------------------------------
def start_menu():
    menu_running = True
    start_button_rect = pygame.Rect(WIDTH//2 - 110, HEIGHT//2 - 50, 220, 80)
    level_button_rect = pygame.Rect(WIDTH//2 - 110, HEIGHT//2 + 50, 220, 80)
    title_font = pygame.font.SysFont("arial", 100, bold=True)
    button_font = pygame.font.SysFont("arial", 50, bold=True)
    current_level = "Level 1"
    
    while menu_running:
        clock.tick(FPS)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit(); sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                pos = pygame.mouse.get_pos()
                if start_button_rect.collidepoint(pos):
                    menu_running = False
                elif level_button_rect.collidepoint(pos):
                    current_level = level_menu(current_level)
            elif event.type in (pygame.FINGERDOWN, pygame.FINGERMOTION):
                pos = (event.x * WIDTH, event.y * HEIGHT)
                if start_button_rect.collidepoint(pos):
                    menu_running = False
                elif level_button_rect.collidepoint(pos):
                    current_level = level_menu(current_level)
                    
        draw_gradient_background(screen, SKY_TOP, SKY_BOTTOM)
        # Startmenütitel: "Super Juljem"
        title_text = title_font.render("Super Juljem", True, RED)
        screen.blit(title_text, title_text.get_rect(center=(WIDTH//2, HEIGHT//2 - 150)))
        pygame.draw.rect(screen, GRAY, start_button_rect, border_radius=15)
        start_text = button_font.render("Start", True, BLACK)
        screen.blit(start_text, start_text.get_rect(center=start_button_rect.center))
        pygame.draw.rect(screen, GRAY, level_button_rect, border_radius=15)
        level_text = button_font.render("Level", True, BLACK)
        screen.blit(level_text, level_text.get_rect(center=level_button_rect.center))
        selected_text = button_font.render("Aktuell: " + current_level, True, BLACK)
        screen.blit(selected_text, selected_text.get_rect(center=(WIDTH//2, HEIGHT//2 + 150)))
        
        pygame.display.flip()
    return current_level

# -----------------------------------------------------------------------------
# LEVELAUSWAHL-MENÜ
# -----------------------------------------------------------------------------
def level_menu(current_selection):
    global max_unlocked
    menu_running = True
    level_keys = sorted(list(levels.keys()), key=lambda x: int(x.split()[1]))
    button_font = pygame.font.SysFont("arial", 50, bold=True)
    title_font = pygame.font.SysFont("arial", 80, bold=True)
    
    while menu_running:
        clock.tick(FPS)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit(); sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                pos = pygame.mouse.get_pos()
                for i, level_name in enumerate(level_keys):
                    level_num = int(level_name.split()[1])
                    rect = pygame.Rect(WIDTH//2 - 120, HEIGHT//2 - 100 + i * 120, 240, 80)
                    if rect.collidepoint(pos) and level_num <= max_unlocked:
                        current_selection = level_name
                        menu_running = False
            elif event.type in (pygame.FINGERDOWN, pygame.FINGERMOTION):
                pos = (event.x * WIDTH, event.y * HEIGHT)
                for i, level_name in enumerate(level_keys):
                    level_num = int(level_name.split()[1])
                    rect = pygame.Rect(WIDTH//2 - 120, HEIGHT//2 - 100 + i * 120, 240, 80)
                    if rect.collidepoint(pos) and level_num <= max_unlocked:
                        current_selection = level_name
                        menu_running = False
        
        draw_gradient_background(screen, SKY_TOP, SKY_BOTTOM)
        title_text = title_font.render("Wähle ein Level", True, RED)
        screen.blit(title_text, title_text.get_rect(center=(WIDTH//2, HEIGHT//2 - 180)))
        
        for i, level_name in enumerate(level_keys):
            level_num = int(level_name.split()[1])
            rect = pygame.Rect(WIDTH//2 - 120, HEIGHT//2 - 100 + i * 120, 240, 80)
            if level_num <= max_unlocked:
                color = LIGHT_GRAY if level_name == current_selection else GRAY
                text = level_name
            else:
                color = DARK_GRAY
                text = level_name + " (Gesperrt)"
            pygame.draw.rect(screen, color, rect, border_radius=15)
            rendered_text = button_font.render(text, True, BLACK)
            screen.blit(rendered_text, rendered_text.get_rect(center=rect.center))
        
        pygame.display.flip()
    return current_selection

# -----------------------------------------------------------------------------
# HELDENSPIELFIGUR IM SUPER-MARIO-STIL (mit Antialiasing, Cap mit "J")
# -----------------------------------------------------------------------------
def create_mario_like_surface(width, height):
    surface = pygame.Surface((width, height), pygame.SRCALPHA)
    cap_height = int(height * 0.45)
    face_height = height - cap_height

    cap_rect = pygame.Rect(0, 0, width, cap_height)
    pygame.gfxdraw.filled_ellipse(surface, width//2, cap_height//2, width//2, cap_height//2, RED)
    pygame.gfxdraw.aaellipse(surface, width//2, cap_height//2, width//2, cap_height//2, RED)
    try:
        cap_font = pygame.font.SysFont("arial", int(cap_height * 0.5), bold=True)
        # Auf der Cap wird nun ein "J" angezeigt
        j_text = cap_font.render("J", True, WHITE)
        surface.blit(j_text, j_text.get_rect(center=(width//2, cap_height//2)))
    except Exception:
        pass

    face_center = (width//2, cap_height)
    face_radius = int(min(width, face_height) * 0.4)
    pygame.gfxdraw.filled_circle(surface, face_center[0], face_center[1], face_radius, SKIN)
    pygame.gfxdraw.aacircle(surface, face_center[0], face_center[1], face_radius, SKIN)
    
    eye_radius = 4
    eye_offset_x = face_radius // 2
    eye_offset_y = -face_radius // 4
    left_eye = (face_center[0] - eye_offset_x, face_center[1] + eye_offset_y)
    right_eye = (face_center[0] + eye_offset_x, face_center[1] + eye_offset_y)
    pygame.gfxdraw.filled_circle(surface, left_eye[0], left_eye[1], eye_radius, WHITE)
    pygame.gfxdraw.filled_circle(surface, right_eye[0], right_eye[1], eye_radius, WHITE)
    pygame.gfxdraw.filled_circle(surface, left_eye[0], left_eye[1], eye_radius - 2, BLACK)
    pygame.gfxdraw.filled_circle(surface, right_eye[0], right_eye[1], eye_radius - 2, BLACK)
    
    mustache_rect = pygame.Rect(face_center[0] - face_radius, face_center[1],
                                2 * face_radius, int(face_radius * 0.8))
    pygame.draw.arc(surface, BLACK, mustache_rect,
                    math.radians(20), math.radians(160), 4)

    overall_top = cap_height + face_radius // 2
    pygame.draw.rect(surface, BLUE, (0, overall_top, width, height - overall_top))
    button_radius = 5
    pygame.gfxdraw.filled_circle(surface, width//2 - 8, overall_top + 10, button_radius, WHITE)
    pygame.gfxdraw.filled_circle(surface, width//2 + 8, overall_top + 10, button_radius, WHITE)
    
    return surface

# -----------------------------------------------------------------------------
# VIRTUELLER JOYSTICK & JUMP-BUTTON
# -----------------------------------------------------------------------------
joystick_center = (150, HEIGHT - 150)
joystick_outer_radius = 160
joystick_knob_radius  = 80
joystick_rect = pygame.Rect(joystick_center[0] - joystick_outer_radius,
                            joystick_center[1] - joystick_outer_radius,
                            2 * joystick_outer_radius,
                            2 * joystick_outer_radius)

jump_button_size = 200
padding = 20
jump_button_rect = pygame.Rect(WIDTH - jump_button_size - padding,
                               HEIGHT - jump_button_size - padding,
                               jump_button_size,
                               jump_button_size)

def draw_joystick(touches):
    pygame.gfxdraw.filled_circle(screen, joystick_center[0], joystick_center[1],
                                 joystick_outer_radius, LIGHT_GRAY)
    pygame.gfxdraw.aacircle(screen, joystick_center[0], joystick_center[1],
                             joystick_outer_radius, GRAY)
    knob_pos = joystick_center
    max_dist_val = 0
    for pos in touches.values():
        if joystick_rect.collidepoint(pos):
            dx = pos[0] - joystick_center[0]
            dy = pos[1] - joystick_center[1]
            dist = math.hypot(dx, dy)
            if dist > max_dist_val:
                max_dist_val = dist
                if dist > joystick_outer_radius:
                    dx *= joystick_outer_radius / dist
                    dy *= joystick_outer_radius / dist
                knob_pos = (int(joystick_center[0] + dx), int(joystick_center[1] + dy))
    shadow_offset = 4
    shadow_pos = (knob_pos[0] + shadow_offset, knob_pos[1] + shadow_offset)
    pygame.gfxdraw.filled_circle(screen, shadow_pos[0], shadow_pos[1],
                                 joystick_knob_radius, (120, 120, 120))
    pygame.gfxdraw.filled_circle(screen, knob_pos[0], knob_pos[1],
                                 joystick_knob_radius, WHITE)
    pygame.gfxdraw.aacircle(screen, knob_pos[0], knob_pos[1],
                             joystick_knob_radius, GRAY)

def draw_jump_button():
    jump_surface = pygame.Surface((jump_button_size, jump_button_size), pygame.SRCALPHA)
    pygame.draw.rect(jump_surface, GRAY, (0, 0, jump_button_size, jump_button_size), border_radius=20)
    center_x = jump_button_size // 2
    center_y = jump_button_size // 2
    pygame.gfxdraw.filled_circle(jump_surface, center_x, center_y - 30, 15, BLACK)
    pygame.draw.line(jump_surface, BLACK, (center_x, center_y - 15), (center_x, center_y + 15), 8)
    pygame.draw.line(jump_surface, BLACK, (center_x - 25, center_y - 10), (center_x, center_y - 5), 8)
    pygame.draw.line(jump_surface, BLACK, (center_x + 25, center_y - 10), (center_x, center_y - 5), 8)
    pygame.draw.line(jump_surface, BLACK, (center_x, center_y + 15), (center_x - 20, center_y + 45), 8)
    pygame.draw.line(jump_surface, BLACK, (center_x, center_y + 15), (center_x + 20, center_y + 45), 8)
    screen.blit(jump_surface, jump_button_rect.topleft)

# -----------------------------------------------------------------------------
# SPIELER, PLATTFORMEN, FINISH FLAG
# -----------------------------------------------------------------------------
class Player(pygame.sprite.Sprite):
    def __init__(self, difficulty=1.0):
        super().__init__()
        self.width, self.height = 50, 75
        self.image = create_mario_like_surface(self.width, self.height)
        self.rect = self.image.get_rect()
        self.rect.x = 200
        self.rect.y = HEIGHT - self.height - 100
        self.vx = 0
        self.vy = 0
        self.speed = 8
        self.jump_strength = 20 / difficulty  
        self.gravity = 0.8 * difficulty
        self.on_ground = False

    def update(self, platforms, horizontal_input, jump):
        self.vx = horizontal_input * self.speed
        if jump and self.on_ground:
            self.vy = -self.jump_strength
            self.on_ground = False
        self.vy += self.gravity
        self.rect.x += self.vx
        self.collide(platforms, self.vx, 0)
        self.rect.y += self.vy
        self.on_ground = False
        self.collide(platforms, 0, self.vy)

    def collide(self, platforms, dx, dy):
        for platform in platforms:
            if self.rect.colliderect(platform.rect):
                if dx > 0:
                    self.rect.right = platform.rect.left
                if dx < 0:
                    self.rect.left = platform.rect.right
                if dy > 0:
                    self.rect.bottom = platform.rect.top
                    self.vy = 0
                    self.on_ground = True
                if dy < 0:
                    self.rect.top = platform.rect.bottom
                    self.vy = 0

class Platform(pygame.sprite.Sprite):
    def __init__(self, x, y, width, height):
        super().__init__()
        self.image = pygame.Surface((width, height))
        self.image.fill(GREEN)
        self.rect = self.image.get_rect(topleft=(x, y))

class FinishFlag(pygame.sprite.Sprite):
    def __init__(self, x, ground_y):
        super().__init__()
        self.image = pygame.Surface((50, 100), pygame.SRCALPHA)
        pygame.draw.rect(self.image, BLACK, (20, 0, 5, 100))
        pygame.draw.polygon(self.image, RED, [(25, 0), (50, 20), (25, 40)])
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.bottom = ground_y

# -----------------------------------------------------------------------------
# HAUPTPROGRAMM (GAME LOOP)
# -----------------------------------------------------------------------------
def main_game(level_config, current_level_name):
    all_sprites = pygame.sprite.Group()
    platforms = pygame.sprite.Group()
    finish_flags = pygame.sprite.Group()

    player = Player(level_config["difficulty"])
    all_sprites.add(player)

    ground = Platform(0, HEIGHT - 50, level_config["ground_width"], 50)
    all_sprites.add(ground)
    platforms.add(ground)

    # Erzeuge die Plattformen und füge PLATFORM_OFFSET hinzu (Plattformen liegen wesentlich tiefer)
    for plat_data in level_config["platforms"]:
        x, y, w, h = plat_data
        plat = Platform(x, y + PLATFORM_OFFSET, w, h)
        all_sprites.add(plat)
        platforms.add(plat)

    # Berechne die X-Position, wo die schwebenden Plattformen enden.
    finish_x = max(x + w for (x, y, w, h) in level_config["platforms"])
    finish_flag = FinishFlag(finish_x, HEIGHT - 50)
    all_sprites.add(finish_flag)
    finish_flags.add(finish_flag)

    touches = {}

    running = True
    while running:
        clock.tick(FPS)
        horizontal_input = 0
        jump = False

        keys = pygame.key.get_pressed()
        if keys[pygame.K_LEFT]:
            horizontal_input = -1
        elif keys[pygame.K_RIGHT]:
            horizontal_input = 1
        if keys[pygame.K_SPACE]:
            jump = True

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit(); sys.exit()
            elif event.type in (pygame.FINGERDOWN, pygame.FINGERMOTION):
                pos = (event.x * WIDTH, event.y * HEIGHT)
                touches[event.finger_id] = pos
            elif event.type == pygame.FINGERUP:
                if event.finger_id in touches:
                    del touches[event.finger_id]
            elif event.type in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEMOTION):
                touches["mouse"] = pygame.mouse.get_pos()
            elif event.type == pygame.MOUSEBUTTONUP:
                if "mouse" in touches:
                    del touches["mouse"]

        touch_horizontal_values = []
        jump_from_touch = False
        for pos in touches.values():
            if jump_button_rect.collidepoint(pos):
                jump_from_touch = True
            if joystick_rect.collidepoint(pos):
                dx = pos[0] - joystick_center[0]
                distance = math.hypot(dx, 0)
                if distance > joystick_outer_radius:
                    dx *= joystick_outer_radius / distance
                touch_horizontal_values.append(dx / joystick_outer_radius)
        if horizontal_input == 0 and touch_horizontal_values:
            horizontal_input = sum(touch_horizontal_values) / len(touch_horizontal_values)
        jump = jump or jump_from_touch

        player.update(platforms, horizontal_input, jump)

        # Level beenden, wenn der Spieler die Zielflagge berührt ODER wenn er hinter die Flagge läuft
        if player.rect.colliderect(finish_flag.rect) or player.rect.left > finish_flag.rect.right:
            running = False

        offset_x = player.rect.centerx - WIDTH // 2

        draw_gradient_background(screen, SKY_TOP, SKY_BOTTOM)
        for sprite in all_sprites:
            draw_pos = (sprite.rect.x - offset_x, sprite.rect.y)
            screen.blit(sprite.image, draw_pos)

        draw_joystick(touches)
        draw_jump_button()
        pygame.display.flip()
    return current_level_name

# -----------------------------------------------------------------------------
# MAIN LOOP: Startmenü, Levelauswahl, Spiel – nach Abschluss des Levels
# wird das nächste Level freigeschaltet (falls vorhanden)
# -----------------------------------------------------------------------------
while True:
    selected_level = start_menu()  # Liefert das derzeit ausgewählte Level
    if selected_level not in levels:
        selected_level = "Level 1"
    main_game(levels[selected_level], selected_level)
    level_num = int(selected_level.split()[1])
    # Level freischalten: Nur wenn das aktuell höchste freigeschaltete Level abgeschlossen wurde.
    if level_num == max_unlocked and max_unlocked < len(levels):
        max_unlocked += 1
